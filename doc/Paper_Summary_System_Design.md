# 论文多阶段总结系统设计方案

> **创建日期**: 2026-01-19  
> **版本**: v1.0  
> **状态**: 设计讨论阶段

---

## 1. 项目概述

### 1.1 目标

构建一个基于 Gemini AI 的自动化论文总结系统，通过多阶段处理将学术论文转换为结构化的 Markdown 笔记文档。

### 1.2 核心特性

- **多阶段处理**: 大纲生成 → 逐段扩写 → 汇总合并
- **结构化输出**: AI 生成 JSON 格式大纲，确保代码可靠解析
- **灵活扩展**: 提示词独立存储，便于迭代优化
- **成本优化**: 根据文档长度智能选择是否使用 Context Caching

---

## 2. 系统架构

### 2.1 整体流程图

```
┌─────────────────────────────────────────────────────────────────────┐
│                          用户上传 PDF 论文                            │
└───────────────────────────────┬─────────────────────────────────────┘
                                │
                                ▼
┌─────────────────────────────────────────────────────────────────────┐
│          预处理: PDF → Markdown (使用 marker-pdf) ✅ 已实现            │
└───────────────────────────────┬─────────────────────────────────────┘
                                │
                                ▼
┌─────────────────────────────────────────────────────────────────────┐
│          论文校验: 验证 Markdown 是否为有效论文格式                     │
│  • 检查第一行是否为 "---" (YAML Frontmatter 起始标记)                  │
│  • 若不符合则跳过，非论文文件不处理                                    │
└───────────────────────────────┬─────────────────────────────────────┘
                                │
                                ▼
┌─────────────────────────────────────────────────────────────────────┐
│          笔记存在性检查: 检查是否已生成笔记                             │
│  • 检查目录中是否存在 {论文名}_笔记.md                                 │
│  • 若已存在则跳过，避免重复处理                                        │
└───────────────────────────────┬─────────────────────────────────────┘
                                │
                                ▼
┌─────────────────────────────────────────────────────────────────────┐
│          资源收集: 上传 Markdown 及相关图片 (*.jpeg)                    │
└───────────────────────────────┬─────────────────────────────────────┘
                                │
                                ▼
┌─────────────────────────────────────────────────────────────────────┐
│          阶段 1: 大纲生成 (Outline Generation)                       │
│  • 加载提示词: 01_outline_generation.md                              │
│  • AI 产出: JSON 格式结构化大纲                                      │
│  • 代码解析: 提取 N 个段落信息                                        │
└───────────────────────────────┬─────────────────────────────────────┘
                                │ 产出: outline.json (包含 N 个段落)
                                ▼
┌─────────────────────────────────────────────────────────────────────┐
│          阶段 2: 逐段扩写 (Section Expansion)                         │
│  • 加载提示词: 02_section_expansion.md                                │
│  • 循环处理: 遍历 N 个段落                                            │
│  • AI 产出: 每段详细 Markdown 内容                                    │
└───────────────────────────────┬─────────────────────────────────────┘
                                │ 产出: sections[0..N-1]
                                ▼
┌─────────────────────────────────────────────────────────────────────┐
│          阶段 3: 汇总合并 (Assembly)                                  │
│  • 拼接所有段落内容                                                   │
│  • 添加 YAML Frontmatter                                              │
│  • 生成目录 (可选)                                                    │
└───────────────────────────────┬─────────────────────────────────────┘
                                │
                                ▼
┌─────────────────────────────────────────────────────────────────────┐
│          输出: 论文笔记.md (保存至 Markdown 原目录)                    │
└─────────────────────────────────────────────────────────────────────┘
```

### 2.2 目录结构

```
D:\code\终端推理\
├── 00_Inbox\                    # 待处理的 PDF 论文
├── 20_Classification\           # 已分类的论文 (Markdown + 图片)
│   ├── 分类A\
│   │   └── 论文名称\            # 论文目录 (包含 .md 和 *.jpeg)
│   │       ├── 论文.md          # 原始 Markdown 论文
│   │       ├── *.jpeg           # 论文相关图片
│   │       └── 论文笔记.md      # 生成的总结 (输出到此处)
│   └── 分类B\
│       └── ...
├── 99_System\
│   ├── prompts\                 # 提示词模板目录
│   │   ├── 01_outline_generation.md    # 大纲生成提示词
│   │   ├── 02_section_expansion.md     # 段落扩写提示词
│   │   └── 03_system_instruction.md    # 系统指令提示词
│   └── scripts\                 # Python 脚本
│       ├── config.py            # 全局配置
│       ├── summarize.py         # 论文总结系统主入口
│       └── summarizer\          # 论文总结模块
│           ├── validator.py     # 论文校验模块
│           ├── uploader.py      # 文件上传模块
│           ├── outline_generator.py  # 大纲生成模块
│           ├── section_expander.py   # 段落扩写模块
│           └── assembler.py     # 汇总合并模块
└── doc\
    ├── Gemini_Context_Caching_Guide.md # 缓存技术指南
    └── Paper_Summary_System_Design.md  # 本设计文档
```

---

## 3. 提示词设计

### 3.1 提示词文件清单

| 文件名                     | 用途           | 输入              | 输出          |
| -------------------------- | -------------- | ----------------- | ------------- |
| `01_outline_generation.md` | 生成结构化大纲 | PDF/Markdown 论文 | JSON 大纲     |
| `02_section_expansion.md`  | 逐段扩写内容   | 段落标题+摘要     | Markdown 内容 |
| `03_system_instruction.md` | AI 角色定义    | -                 | -             |

### 3.2 大纲 JSON Schema

```json
{
  "paper_title": "string - 论文标题",
  "authors": "string - 作者信息",
  "year": "string - 发表年份",
  "one_liner": "string - 论文核心贡献一句话总结（50-80字）",
  "sections": [
    {
      "id": "number - 段落序号 (1-based)",
      "title": "string - 段落标题",
      "subsections": [
        {
          "subtitle": "string - 子标题",
          "key_points": ["string[] - 需要详细解释的关键要点列表"]
        }
      ],
      "key_figures": ["string[] - 相关图片列表"],
      "key_formulas": "boolean - 是否包含重要公式"
    }
  ]
}
```

### 3.3 格式规范

为确保最终 Markdown 文档的统一性，所有阶段需遵循以下规范：

1. **数学公式**: LaTeX 格式，行内 `$...$`，独立 `$$...$$`
2. **中英文混排**: 英文单词和数字前后保留空格
3. **图片引用**: 使用 `<图片 X>` 格式 (不嵌入实际图片)
4. **标题层级**:
   - `#` 论文标题
   - `##` 主要段落
   - `###` 段落内一级
   - `####` 段落内二级

---

## 4. Context Caching 策略

### 4.1 使用决策树

```
                    计算论文 Token 数量
                           │
              ┌────────────┴────────────┐
              │                         │
         < 32K Tokens              ≥ 32K Tokens
              │                         │
              ▼                         ▼
     ┌─────────────────┐      ┌─────────────────┐
     │  不使用缓存       │      │   使用缓存       │
     │  直接放入 Prompt  │      │  创建 cache_id  │
     └─────────────────┘      └─────────────────┘
```

### 4.2 策略对比

| 特性           | 无缓存模式              | 缓存模式                         |
| -------------- | ----------------------- | -------------------------------- |
| **适用场景**   | 单篇标准论文 (10-30页)  | 超长文档 / 批量论文              |
| **Token 门槛** | < 32K                   | ≥ 32K                            |
| **API 调用**   | 每次传全文              | 创建一次，后续引用 ID            |
| **成本**       | 按全量 Input Token 计费 | 创建费 + 存储费 + 少量 Prompt 费 |
| **实现复杂度** | 简单                    | 需管理 TTL、缓存 ID              |

### 4.3 缓存管理注意事项

1. **TTL 管理**: 默认 60 分钟，可根据需要调整或续期
2. **异常处理**: 缓存过期时捕获 404 错误，自动重建
3. **资源清理**: 任务完成后可删除缓存，节省存储费用

---

## 5. 预处理详解

### 5.1 论文校验逻辑

在处理 Markdown 文件之前，需要验证其是否为有效的论文文件。

**校验规则**:

```python
def is_valid_paper(file_path: str) -> bool:
    """
    校验 Markdown 文件是否为有效论文。
    规则: 第一行必须是 "---" (YAML Frontmatter 起始标记)
    """
    with open(file_path, 'r', encoding='utf-8') as f:
        first_line = f.readline().strip()
        return first_line == "---"
```

**校验流程**:

1. 读取文件第一行
2. 检查是否为 `---` (YAML Frontmatter 起始标记)
3. 若不符合，跳过该文件并记录日志
4. 若符合，继续后续处理

**设计原因**:

- 经过 `marker-pdf` 处理的论文会自动添加 YAML Frontmatter
- 非论文文件 (如笔记、README) 通常不以 `---` 开头
- 此校验可有效过滤误放入目录的非论文文件

### 5.2 笔记存在性检查

在处理论文之前，需要检查目标笔记文件是否已存在，避免重复生成。

**检查规则**:

```python
def should_skip_paper(paper_md: Path, output_suffix: str) -> bool:
    """
    检查论文是否应该跳过处理。
    规则: 如果笔记文件已存在，则跳过

    笔记文件命名规则: {论文名}{output_suffix}.md
    例如: 论文.md -> 论文_笔记.md
    """
    output_path = paper_md.parent / f"{paper_md.stem}{output_suffix}.md"
    return output_path.exists()
```

**处理流程**:

1. 根据论文 Markdown 文件名构造笔记输出路径
2. 检查笔记文件是否已存在
3. 若已存在，记录日志并跳过该论文
4. 若不存在，继续后续处理

**设计原因**:

- **避免重复处理**: 已生成笔记的论文无需再次调用 AI，节省 Token 成本
- **支持增量处理**: 批量扫描时仅处理新增论文
- **幂等性保证**: 多次运行脚本不会覆盖已有笔记

### 5.3 资源上传

上传论文时需同时上传 Markdown 文件及相关图片资源。

**上传内容**:

| 文件类型 | 匹配规则 | 用途                   |
| -------- | -------- | ---------------------- |
| Markdown | `*.md`   | 论文主体内容           |
| 图片     | `*.jpeg` | 论文中的图表、公式截图 |

**实现逻辑**:

```python
def collect_paper_resources(paper_dir: str) -> list[str]:
    """
    收集论文目录下的所有资源文件。
    包括: Markdown 文件 + JPEG 图片
    """
    resources = []

    # 收集 Markdown 文件
    md_files = glob.glob(os.path.join(paper_dir, "*.md"))
    resources.extend(md_files)

    # 收集 JPEG 图片
    jpeg_files = glob.glob(os.path.join(paper_dir, "*.jpeg"))
    resources.extend(jpeg_files)

    return resources
```

**Gemini API 多模态上传**:

```python
import google.generativeai as genai

def upload_to_gemini(resources: list[str]) -> list:
    """
    将资源文件上传至 Gemini API。
    支持多模态输入 (文本 + 图片)。
    """
    uploaded_files = []
    for file_path in resources:
        uploaded = genai.upload_file(file_path)
        uploaded_files.append(uploaded)
    return uploaded_files
```

**注意事项**:

- 图片和 Markdown 需在同一请求中传入，AI 才能关联分析
- JPEG 格式兼容性最好，其他格式可能需要预转换
- 大图片会消耗较多 Token，建议适当压缩

---

## 6. 处理流程详解

### 6.1 阶段一: 大纲生成

**输入**:

- 论文 Markdown 内容
- `01_outline_generation.md` 提示词

**处理逻辑**:

1. 加载系统指令和大纲生成提示词
2. 将论文内容 + 提示词发送给 Gemini API
3. 解析返回的 JSON 大纲
4. 验证 JSON 结构完整性
5. 存储到临时文件 `outline.json`

**输出**:

- 结构化的 JSON 大纲对象
- 包含 N 个段落 (由 AI 自主决定)

**容错处理**:

- JSON 解析失败时，尝试使用正则提取 `{...}` 块
- 可引入 `json-repair` 库修复常见格式错误
- 重试机制 (最多 3 次)

### 6.2 阶段二: 逐段扩写

**输入**:

- 大纲 JSON 中的每个 section
- `02_section_expansion.md` 提示词
- 论文原文 (作为上下文)

**处理逻辑**:

```
FOR each section IN outline.sections:
    1. 填充提示词模板变量
    2. 发送请求给 Gemini API
    3. 收集返回的 Markdown 内容
    4. 存入 sections_content 数组
END FOR
```

**上下文策略**:

- **无状态模式**: 每次请求独立，无需保持会话历史
- **有状态模式**: 使用 `chat_session`，后续段落可引用前文

**推荐**: 无状态模式，更稳定且易于并行处理

### 6.3 阶段三: 汇总合并

**输入**:

- 大纲 JSON
- N 个段落的 Markdown 内容

**处理逻辑**:

1. 生成 YAML Frontmatter (标题、日期、标签等)
2. 按顺序拼接所有段落内容
3. 添加论文标题作为 `#` 一级标题
4. 每个段落添加 `##` 二级标题
5. (可选) 生成目录 TOC
6. 写入最终 Markdown 文件

**输出格式**:

```markdown
---
title: 论文标题
authors: 作者信息
year: 发表年份
created: 生成日期
tags: [paper-notes, auto-generated]
---

# 论文标题

## 段落 1 标题

(扩写内容...)

## 段落 2 标题

(扩写内容...)

...
```

---

## 7. 错误处理与边界情况

### 7.1 常见错误类型

| 错误类型      | 原因            | 处理方案               |
| ------------- | --------------- | ---------------------- |
| JSON 解析失败 | AI 输出不规范   | 正则提取 + json-repair |
| 缓存 404      | TTL 过期        | 自动重建缓存           |
| API 限流      | 请求过于频繁    | 指数退避重试           |
| 内容截断      | 输出 Token 超限 | 减少单次扩写范围       |

## 8. 扩展方向

### 8.1 多模态支持

- 将论文图片一并上传 Gemini
- AI 能够"看图说话"，提供更精准的图片分析

---

## 9. 附录

### 9.1 相关文档

- [Gemini Context Caching 技术指南](./Gemini_Context_Caching_Guide.md)

### 9.2 提示词文件位置

```
D:\code\终端推理\99_System\prompts\
├── 01_outline_generation.md
├── 02_section_expansion.md
└── 03_system_instruction.md
```

### 9.3 参考资源

- [Google Gemini API 文档](https://ai.google.dev/docs)
- [google-generativeai Python SDK](https://github.com/google/generative-ai-python)
